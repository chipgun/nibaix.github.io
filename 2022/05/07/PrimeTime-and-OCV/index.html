<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta name="description" content="">
  <meta name="author" content="">
  <link rel="icon" href="/img/favicon.png">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5/dist/css/bootstrap.min.css">


  
<link rel="stylesheet" href="/css/style.css">


  
  <title>PrimeTime and Timing Derate - 芝士盒</title>
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  <header>
    <nav id="navbar" class="navbar fixed-nav scrolling-navbar">
  <div class="container">
    <div class="mark-wrapper">
      
        <img class="logo" src="/img/avatar.png "/>
       
      <div class="title-mark">芝士盒</div>
    </div>
  
    <button id="menu-btn" class="btn menu-btn" type="button" data-bs-toggle="collapse" data-bs-target="#nav-menu">
      <div class="menu-icon"><span></span><span></span><span></span></div>
    </button>
  
    <div id="nav-menu" class="collapse menu-wrapper">
      <ul>
        
          <li>
            <a href="/">Home </a>
          </li>
        
          <li>
            <a href="/archives">Archives </a>
          </li>
        
          <li>
            <a href="/categories">Category </a>
          </li>
        
          <li>
            <a href="/tags">Tag </a>
          </li>
        
          <li>
            <a href="/about">About </a>
          </li>
        
        <li class="search-icon">
          <button class="btn" data-bs-toggle="modal" data-bs-target="#searchModal" aria-label="Search">
            <i class="fas fa-search"></i>
          </button>
        </li>
      </ul>
    </div>
  </div>
</nav>

  </header>

  <main>
    <div class="container">
      <div id="main">
        <div class="row py-5">
          <div class="col">
            <div class="row">
  <div class="left-content">
    <article class="post-wrapper markdown-body">
  <h2 class="post-title">
    PrimeTime and Timing Derate
  </h2>
  <div class="post-meta">
    <time datetime="Invalid date Invalid date ">2022-05-07</time>
    
    
      
        <a class="tag" href="/categories/VLSI/">VLSI</a> 
       
    
    
      
        <a class="tag" href="/tags/synopsys/">synopsys</a> 
      
        <a class="tag" href="/tags/ocv/">ocv</a> 
      
        <a class="tag" href="/tags/sta/">sta</a> 
       
    
    
  </div>
  
  <div id="content">
    <p>We learned OCV in a few other posts. However running OCV at 2 different PVT corners may not always be practical. For ex, consider the voltage drops seen on a chip due to IR. We may not be able to get lib at that particular voltage corner after accounting for the voltage drop due to IR. Similarly for temperature, we may not be able to lib for that exact temperature after accounting for on chip heating. Also, even if we are able to get these libs, ocv analysis requires running at 2 extreme corners. If we do not want to run analysis at 2 diff corners for ocv, we can run it at 1 corner only by specifying derating. Derating is an alternate approach where we speed up or slow down certain paths so that they can indirectly achieve same results as OCV. Derating is basically applying a certain multiplying factor to each gate delay so that the delay can be scaled up (by having a multiplying factor &gt; 1), or can be scaled down (by having a multiplying factor &lt; 1). The advantage of derate is that each and every gate in design can now be customized to have a particular delay on it. With OCV analysis, we weren’t able to do this, as the flow just chose b&#x2F;w WC and BC lib and applied one or the other to each gate in design. Here, we first choose a nominal voltage, for which we have library available, and then apply derate to achieve effects of Voltage and Temperature variations.</p>
<span id="more"></span>

<p>There are different kind of derates:</p>
<ul>
<li><strong>Timing derates:</strong> When we run sta at particular voltage&#x2F;temperature, we assume same voltage and same temperature on all transistors. However, based on IR drop and temperature variation as well as aging effect, we know that not all transistors will be on same voltage&#x2F;temperature. So, we apply timing derating. We apply these timing derates as “voltage guardband derates”. Even though we say voltage, we include effect of temperature and aging effect, so that the “voltage derate” includes effects of all of these. In PT flow, these derates specified via “set_timing_derate -pocvm guardband” or “set_timing_derate -aocvm guardband” &#x3D;&gt; This is explained later. By default, derate specify ocv derate, which are derates due to local process variations only. Then we apply either aocv or pocv voltage guardband derate, which account for Voltage+Temperature+reliability derates. </li>
<li><strong>POCVM distance derates:</strong> Only applied on clocks. This is additional derate on top of voltage derate above.</li>
<li><strong>LDE (Layout dependent Effect) derates</strong>: provided by foundry. Applied as incremental derate</li>
<li><strong>MixedVt &#x2F; MixedLg derates:</strong> Differences in Threshold voltage as well as in “Length” of transistors, we experience differences in delay which don’t scale same way. i.e process is not correlated for different VT, so LVT might be at SS -3σ corner, but ULVT instead of being perfectly at SS -3σ corner, it may be a little bit faster or slower. e.g. in a slow-slow corner the capture clock is LVT and might be slightly faster than fast-fast corner due to Vt mistracking. This VT mistracking is not OCV related. OCV models local process variations, while Mixed VT is modeling global process corner correlation. We model this MixedVt correleation effect via derate.</li>
<li><strong>Margining derates:</strong> Other derates used for margining</li>
</ul>
<p>What derating factor to apply for ocv&#x2F;aocv&#x2F;pocv is derived by running monte carlo sims.</p>
<p><strong>1. set_timing_derate</strong> &#x3D;&gt; It allows us to adjust delays by a multiplying factor. It automatically sets op cond to ocv mode. The derating factor applies only to the specified objects which is a collection of cells, lib_cells or nets. If no objects specified, then derating applies to whole design. report_timing -derate shows timing with derating factor shown for each cell&#x2F;net in the path. We do not derate slews or constraint arcs (as they are not supported for AOCV or POCV), but we do have options for setting these in set_timing_derate cmd.</p>
<p>options:</p>
<p>-early&#x2F;-late &#x3D;&gt; unlike other cmds, there is no default here. We have to specify -early to apply derating on early (shortest delay) path, and -late for late (longest delay) path. We need to have separate cmd for early and late, else derating will get applied to only 1. The tool applies worst-case delay adjustments, both early and late, at the same time. For example, for a setup check, it applies late derating on the launch clock path and data path, and early derating on the capture clock path. For a hold check, it does the opposite. We get these derating values from simulations. First, we try to find worst&#x2F;best case voltage drop on transistor power pins (after accounting for off chip IR drop, PMU overshoot&#x2F;undershoot and on chip IR drop) and then apply derating accordingly. </p>
<ul>
<li>Early derating: We apply early derating corresponding to the voltage level which would be with off chip IR drop only. This is the absolute highest voltage that can be seen by any transistor on die. Then we add extra derate to account for temperature offset. We apply same early derate for both clk and data path.</li>
<li>Late derating: We apply late derating corresponding to the voltage level which would be with off chip IR drop + on chip IR&#x2F;power_switch drop + reliability margin (due to VT shift seen for transistors with low activity). This is the absolute lowest voltage that can be seen by any transistor on die. Here, we apply slightly different derate for clk and data path. For clock path, we don’t add the reliability margin, since clk is always switching, so there is no reliability penalty that the clk path incurs. So, clk path sees a slightly higher voltage.</li>
</ul>
<p>NOTE: since we apply these early&#x2F;late derates, we want our nominal voltage at which we are going to run STA to be around these early&#x2F;late voltages. If our librar’s nominal voltage is too far from these early&#x2F;late voltages, then we have to apply large derating, which may not produce accurate results.</p>
<p>-cell_delay&#x2F;-net_delay &#x3D;&gt; By default, derating applies to both cell and net delays, but not to cell timing check constraints. This allows derating to apply only to cell or net delays. -cell_check allows derating to be applied to cell timing check constraints (setup&#x2F;hold constraints)</p>
<p>-data&#x2F;-clock &#x3D;&gt; By default, delays are derated in both data paths and clock paths. This allows derating to be applied to only data or clock</p>
<p>-rise&#x2F;-fall &#x3D;&gt; By default, both rising and falling delays are derated. This allows derating to be applied to cell&#x2F;net delays that end with a rising or falling transition only</p>
<p>There are many more options that we’ll see later (including -aocvm guardband&#x2F;-pocvm guardband options). If the options -aocvm guardband&#x2F;-pocvm guardband are not used, then the above derating cmd sets OCV derate, which ony accounts for local process variation related derate. Voltage&#x2F;Temperature and Reliability derates are captured via additional derate specified with -aocvm guardband&#x2F;-pocvm guardband options. Thus OCV derate and aocv&#x2F;pocv guardband derate are all needed to account for all PVT+reliability variations.</p>
<p>ex: <code>set_timing_derate -early 0.9; set_timing_derate -late 1.2</code> &#x3D;&gt; The first command decreases all early (shortest-path) cell and net delays by 10 percent, such as those in the data path of a hold check (and clk path of setup check). The second command increases late (longest-path) cell and net delays by 20 percent, such as those in the data path of a setup check (and clk path of hold check). These two adjustments result in a more conservative analysis. We should use derating &lt; 1 for early and &gt;1 for late, since we are trying to simulate worst case ocv that can happen. Derating gets applied to whole design, as we did not specify any object.</p>
<p>ex: <code>set_timing_derate -increment -cell_delay -data -rise -late 0.0171 [get_lib_cells &#123; TSM_svt_ff_1v_125c_cbest/SDF_NOM_D1_SVT&#125;]</code> &#x3D;&gt; applies derating of 1.7% only to lib cell specified for rise dirn, and long delay path. -increment adds this derating on top of any derating that is already applied globally or to this cell earlier.</p>
<p>ex: <code>set_timing_derate -cell_delay -net_delay -late 1.05 [get_cells top/H1]</code> &#x3D;&gt; sets a late derating factor on all cells and nets in the hierarchical cell top&#x2F;H1, including its lower-level hierarchical cells</p>
<p><code>report_timing_derate</code> &#x3D;&gt; shows derates set for all cells in design. This is very long list so better to redirect it to some o&#x2F;p file</p>
<p><strong>AOCV and POCV:</strong> OCV is OK, but it doesn’t model advanced levels of variations for 65nm and below, which results in overdesign. OCV allows us to model different derating for diff cells (by using set_timing_derate cmd), but fails to capture other factors. To mitigate some of these OCV issues, advanced forms of OCV came into picture. AOCV (advanced OCV) was used earlier, but even more advanced POCV (parametric OCV) is used now. We will go over details of both</p>
<p>PT has app_var variables which allow advanced OCV and parametric OCV. To report all app_var, we can use this cmd:</p>
<p><code>pt_shell &gt; report_app_var *ocv*</code> &#x3D;&gt; reports all aocv and pocv app_var settings</p>
<p>AOCV: <code>timing_aocvm_enable_analysis</code> &#x3D;&gt; setting it to true enables AOCV) &#x3D;&gt; needs AOCV tables in a side file</p>
<p>POCV: <code>timing_pocvm_enable_analysis</code> &#x3D;&gt; setting it to true enables POCV) &#x3D;&gt; needs POCV side file or liberty file</p>
<p><strong>AOCV: Advanced on chip variation</strong></p>
<p>OCV doesn’t handle below factors:</p>
<ol>
<li>path depth &#x3D;&gt; variation reduces on long paths due to statistical canceling. So, even if each cell has lot of variations, due to random nature of variations, they can be +ve variation or -ve variation. More the gates in design, higher the changes that +ve and -ve variations will cancel out, resulting in very low level of variations. So, path depth is a factor only for random variations on die.</li>
<li>path distance &#x3D;&gt; variation increases as paths travels across more die area. This is based on simple silicon observation that close by structures have less variation, but if you compare structure far away, they have larger variation. That is why in analog circuits, matching transistors are placed as close as possible to each other to minimize variations b&#x2F;w them. So, path distance is a factor only for systematic spatial variations on die. Even if you have more gates in design but they are closeby, then spatial variations will be very low, compared to when these gates are far away. In other words, we are saying that these variations are correlated more or less depending on their proximity with each other. So, total variation in any path is function of both random variation as well as spatial variation. However random variation dominate, so path distance based variation is not very critical.</li>
<li>different cell types &#x3D;&gt; variations varies depending on transistors used in cells. Lower width transistor have more variations that larger width ones. However, cell level derating is already captured in simple derating cmd above, as it allows us to set different derates for different kinds of cells.</li>
</ol>
<p>AOCV was proposed to provide path depth and distance based derating factors to capture random and systematic on-die variation effects respectively. Instead of applying a constant derating factor as in ocv to any cell, we adjust the derating factor for a given cell based on path distance and depth. This is provided in form of a 2D table in a file. AOCV provides a single number for delay of a path based on derating used (derating value itself is taken from 2D table based on path depth and path distance for that cell). It only models delay variation, but does not model transition or constraint variation. Thus AOCV is siame as OCV except for derating added for above 2 factors.</p>
<p>Both GBA and PBA AOCV can be performed. GBA AOCV reduces pessimism by some compared to GBA OCV, which may be sufficient for signoff. If few paths still fail, PBA AOCV can be run on selected failing paths, which reduces pessimism even further.</p>
<p><strong>AOCV flow:</strong></p>
<p><code>set_app_var read_parasitics_load_locations true</code> &#x3D;&gt; this is so that read_parasitics can read location info from spef file</p>
<p><code>read_parasitics file.spef</code> &#x3D;&gt; To use distance based derating specified in aocv file below, we need physical location of various gates, nets, etc. This info is contained in SPEF files, and can be read via read_parasitics cmd. If we have hirarchical flow, where there are separate spef files for blocks and for top lvel, PT can automatically determine correct offset and orientation of blocks. However, if it fails, we can specify it manually via extra args in read_parasitics cmd.</p>
<p><code>set_app_var timing_aocvm_enable_analysis true</code> &#x3D;&gt; sets GBA POCV analysis</p>
<p><code>read_ocvm file.aocvm</code> &#x3D;&gt; reads derating from this aocvm file. It has 2D table of derates with depth and distance as index (It can also be 1D table with either depth or distance as index, although this will give less accurate results). aocv derate take precedence over ocv derate specified for any cell, as it’s more accurate. Syntax of this file is explained under pocv section below.</p>
<p><code>set_timing_derate -aocvm_guardband -early 0.95</code> &#x3D;&gt; this applies additional guardband to model non proces related effects (ir drop, margin, etc) in aocv flow. For fast paths, we reduced delays by further 5%. Final derate &#x3D; aocv_derate * guardband_derate. set_timing_derate -increment adds derate on top of this derate (instead of multiplying, it adds). So, Final derate &#x3D; aocv_derate * guardband_derate + incremental_derate. Either guardband derate or incremental derate can be applied, as two are mutually exclusive.</p>
<p><code>set_timing_derate -aocvm_guardband -late 1.04</code> &#x3D;&gt; For slow paths, we increased delays by 4%.</p>
<p><code>update_timing</code> &#x3D;&gt; performs timing update</p>
<p><code>report_ocvm -type aocvm</code> &#x3D;&gt; reports number of cells&#x2F;nets that aocvm deratings were applied on, in summarized table. Any cell&#x2F;net not-annotated with derate is listed here.</p>
<p><code>report_ocvm -type aocvm I0/U123</code> &#x3D;&gt; If object list specified, derating on specific instances or arcs reported</p>
<p><code>report_timing</code> &#x3D;&gt; shows timing paths with aocv analysis. -derate shows derate factor too</p>
<p><strong>POCV: Parametric on chip variation</strong></p>
<p>POCV is even more advanced, and radical departure from conventional methods. Here, timing values are stored not as one single number but rather as statistical quantities (i.e as a gaussian distribution with mean u and std dev sigma). These statistical distribution are propagated along the path, and probabllity&#x2F;statistics theorems applied to come with a statistical distribution for the final delay at end point of a path. AOCV models deratings only for delay, but POCV statistical method is applied not only for delay, but also for transition variation for each cell on a path. It also models constraint variation (setup&#x2F;hold times on flops), as these vary too depending on variation within the cell, as well as transition variation on clk and data pins. mu and sigma values are stored in lib files for each cell for delay, transition and constraint (only if provided for flops). By defauly, only delay variation is enabled. Transition variation and constraint variation have to be enabled to get better match with HPSICE monte carlo sims. Timing values can be reported at any N sigma corner (since sigma is known). Usually, we report it at 3 sigma, as that implies 99.9% of the dies for that timing path will lie within 3 sigma (i.e only 0.1% of chips will fail for that path).</p>
<p>POCV takes care of path depth automatically, as it propagates each distribution as independent random variable. So, statistically cancellation takes care of path depth. path distance is handled by using distance based AOCV tables. So, these tables are 1D in case of POCV (as opposed to 2D tables in AOCV).</p>
<p>Lower VDD, as found in low nm tech, increases sensitivity to delay, transition and constraint variation (as Vdd is close to Vth, so small change in Vdd causes large changes in current) . So, POCV accounts for all this sensitivity, and prevents overdesign during PnR. POCV run with GBA provides better coorelation with PBA, as it reduces pessimism in GBA. On other hand, with AOCV, exhaustive PBA had to be run at signoff as GBA has inbuilt pessimism, increasing run time. Tight GBA PBA corelation in POCV prevents running exhaustive PBA.</p>
<p>POCV is run in PT as regular flow. The only extra step is reading variation information from liberty files, or from sidefiles in AOCV like table. Then timing is reported at specific sigma corner.</p>
<p><strong>POCV input data:</strong> 2 methods: One is providing a sidefile for distance based derating (or single sigma value called as single coefficient), and the other is liberty file with sigma values across i&#x2F;p slew rate and o&#x2F;p load. derate in POCV can be applied to both mean or sigma values. derate is applied to mean values available in .lib file, and sigma values available in .lib file or in sdefile as single coeff.</p>
<p><em>1. sidefile with POCV single coefficient:</em> This sidefile is just an extension of AOCV table format in version 4.0 (this is same synopsys file format as shown in AOCV section). It can either have distance based derate, or constant coefficient for sigma. Syntax is as below: (file1.pocvm or file1.aocvm or any name)</p>
<p>version: 4.0</p>
<p>ocvm_type: pocvm &#x3D;&gt; it can be aocvm or pocvm<br>object_type: lib_cell &#x3D;&gt; this can be design, lib_cell or hier cell<br>rf_type: rise fall &#x3D;&gt; for both rise&#x2F;fall</p>
<p>voltage: 0.9 &#x3D;&gt; this allows voltage based derating where diff derate can be applied based on voltage the cell is at.<br>delay_type: cell &#x3D;&gt; this can be cell or net. For net, object_spec is empty to apply it for all nets<br>derate_type: early &#x3D;&gt; early means it’s applied on shortest paths (for setup, clk paths are early, while for hold, data paths are early &#x3D;&gt; to model worst case scenario)<br>path_type: clock &#x3D;&gt; below derating is applied only for cells in clk path (applicable only for setup). For cells in data path for early (applicable only for hold), we may specify a different derating (&lt;1).<br>object_spec: -quiet TSM_LIB&#x2F;* &#x3D;&gt; applies to all cells. For particular cells, we can do TSM_LIB&#x2F;invx1*. -quiet prevents warnings from showing up<br>distance: 0 5000000 10000000 20000000 30000000 40000000 &#x3D;&gt; this specfies distance for derating purpose<br>table: 1.000000 0.990442 0.986483 0.980885 0.976588 0.972967 &#x3D;&gt; since type is early (fast paths), derates are &lt; 1 to model worst scenario.</p>
<p>coefficient: 0.05 &#x3D;&gt; this specifies single coefficient which is sigma divided by mean &#x3D; sigma&#x2F;mu (random variation coeff normalized with mu). This is specified if we want to do single coeff based POCV for our timing runs, instead of more accurate liberty based sigma. However, coeff and distance are mutually exclusive, you can specify only one of them. Different values can be specified for diff cells, etc. Usually more accurate lib files used to provide sigma, instead of providing coefficient here.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ocvm_type: pocvm</span><br><span class="line">object_type: lib_cell</span><br><span class="line">rf_type: rise fall</span><br><span class="line">delay_type: cell</span><br><span class="line">derate_type: late =&gt; late means it<span class="string">&#x27;s applied on longest paths</span></span><br><span class="line"><span class="string">path_type: clock =&gt; below derating only for cells on clk path (applicable only for hold). We specify derating separately for cells on data path for late (applicable only for setup)</span></span><br><span class="line"><span class="string">object_spec: -quiet TSM_LIB/*</span></span><br><span class="line"><span class="string">distance: 0 5000000 10000000 20000000 30000000 40000000</span></span><br><span class="line"><span class="string">table: 1.000000 1.009558 1.013517 1.019115 1.023412 1.027033</span></span><br></pre></td></tr></table></figure>
<p>&#x3D;&gt; since type is late (slow paths), derates are &gt; 1 to model worst scenario. </p>
<p>coefficient: 0.02</p>
<p><em>2. LVF (liberty variation format) file:</em> These file have additional groups which contain sigma info for delay, transition and constraint variation. They may also have distance based derating values here, instead of being in a sidefile (using ocv_derate group)</p>
<p> format of this explained in Liberty section</p>
<p><strong>POCV flow:</strong></p>
<p><code>set_app_var read_parasitics_load_locations true</code> &#x3D;&gt; this is so that read_parasitics can read location info from spef file</p>
<p><code>read_parasitics file.spef</code> &#x3D;&gt;</p>
<p><code>set_app_var timing_pocvm_enable_analysis true</code> &#x3D;&gt; sets GBA POCV analysis</p>
<p><code>set_app_var timing_pocvm_corner_sigma 3</code> &#x3D;&gt; sets corner value for timing to be 3 sigma. It can be set to 5 sigma for more conservative analysis</p>
<p><code>set_app_var timing_enable_slew_variation true</code> &#x3D;&gt; to enable transition variation (i&#x2F;p slew variation affects delay variation as well as o&#x2F;p transition variation). Optional but recommended for better accuracy at &lt; 16nm</p>
<p><code>set_app_var timing_enable_constraint_variation true</code> &#x3D;&gt; to enable constraint variation (setup&#x2F;hold, rec&#x2F;rem, clkgating variation). Optional but recommended for better accuracy at &lt; 16nm</p>
<p><code>read_ocvm file.pocvm</code> &#x3D;&gt; reads single coeff or distance based derating from side file based on what’s available</p>
<p><code>set_timing_derate -pocvm_guardband -early 0.95</code> &#x3D;&gt; For fast paths, we reduced delays by further 5%. POCV guardband is applied on both mean delay and sigma delay (AOCV guardband is only for mean delay, as there’s no concept of sigma in AOCV). If we want to derate only sigma delay, we can scale pcvm coefficient in sidefile or liberty file (w&#x2F;o modifying the value directly in sidefile or liberty file) by using “set_timing_derate -pocvm_coefficient_scale_factor 1.03” to scale it, which scales only sigma and not mean delay. However, pocvm coeff scaling is applied on top of guardband for sigma delay.</p>
<ul>
<li>Final derate_mean &#x3D; pocv_derate * guardband_derate + incremental_derate,</li>
<li>Final_derate_sigma &#x3D; guardband_derate * pocvm_coefficient_scale_factor</li>
</ul>
<p><code>set_timing_derate -pocvm_guardband -late 1.04</code> &#x3D;&gt; For slow paths, we increased delays by 4%</p>
<p><code>update_timing</code> &#x3D;&gt; performs timing update</p>
<p><code>report_ocvm -type pocvm</code> &#x3D;&gt; reports summarized pocvm deratings applied on cells&#x2F;nets. If object list provided, it shows coeff and distance based derating picked from sidefile or LVF</p>
<p><code>report_timing</code> &#x3D;&gt; shows timing paths with aocv analysis. -derate shows derate factor too. However, now we may want to see both mean and sigma delays (since sigma delays are taken into account when reporting slack). slacks are not simple difference b&#x2F;w expected arrival time and atual arrival time, but are square root of squares of these (since now we are dealing with statistical quantities). To see both mean and sigma delays, set this app var:</p>
<p><code>set_app_var variation_report_timing_increment_format delay_variation</code> &#x3D;&gt; Now report_timing -derate will show 2 columns: mean (delay w&#x2F;o variation) and sensit (sigma or delay variation). Incremental time column for that arc should equal mean +&#x2F;- 3*sensit (+ or - depending on slow(max) or fast(min) paths). mean and sensit are with derating already applied. Apart from incremental colums, there is also path colums, which show both mean and sensit again. Mean here is the cummulative mean upto that point (sum of all means), while sensit is cummulative sensitivity upto that point (sqrt of sqaures of all sigma). These help to verify various path delays and how they contribute to overall delays. There are also statistical corrections applied to get numbers to add up. There is also statistical graph pessimism applied in timing analysis. Latch borrowing also needs to be treated differently when in POCV mode.</p>
<ul>
<li>final cell_delay mean derated &#x3D; Cell_delay_mean * final_derate_mean &#x3D; cell_delay * ( “POCVM guardband” * “POCVM distance derate” + “Incremental derate” )</li>
<li>final cell_delay sigma derated &#x3D; cell_delay_sigma_adjusted * final_derate_sigma &#x3D; cell_delay_sigma_adjusted * ( “POCVM guardband” * pocvm_coefficient_scale_factor) &#x3D;&gt; cell_delay_sigma here is adjusted from the original sigma number reported in liberty file (if LVF used) by accounting for the fact that transition variation on i&#x2F;p will affect delay variation (as well as o&#x2F;p transition variation) depending on correlation b&#x2F;w transition and delay. There is proprietery formula applied by synopsys to come up with adjusted sigma number.</li>
</ul>
<p>Now <code>update_timing</code> runs aocv, and <code>report_timing</code> shows timing paths with pocv analysis.</p>
<p><code>report_delay_calculation -from buf1/A -to buf1/Z -derate</code> &#x3D;&gt; This shows detailed calculation of cell mean delay and cell sigma delay with derating. This is useful for debug.</p>
<p><strong>POCV analysis with xtalk:</strong> POCV analysis is only applied on non-SI cell delay. However, POCV can indirectly change crosstalk delta delay due to the difference in timing window alignment.</p>
<p><strong>POCV characterization</strong>: POCV data can be generated via Synopsys SiliconSmart too, It can generate sigma for use in LVF, or coeff for use in pocv side file. distance based derating in sidefile can’t be generated via any tool, and is generated via silicon measurements</p>

  </div>

</article>
  </div>
  <div class="right-content">
    <div id="toc" class="toc-wrapper"></div>
  <div>
</div>


          </div>
        </div>
      </div>
    </div>

     
  <button id="scroll-to-top" class="btn btn-top" aria-label="Scroll To Top">
    <i class="fas fa-arrow-up"></i>
  </button>
 

  </main>

  <div class="footer-wrapper">
  <div class="left-content"></div>
  <div class="right-content">
    <div>Copyright &copy;2025</div>
    <div>Powered By <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> - Theme <a target="_blank" rel="noopener" href="https://github.com/thomasyu929/hexo-theme-peomas">Peomas</a></div>
  </div>
</div>

  <div id="searchModal" class="modal fade" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Search</h5>
        <button type="button" class="btn btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="input-wrapper">
          <i class="fas fa-search"></i>
          <input id="search" class="search-input" type="text" placeholder="Input content to search..." />
        </div>
        <ul id="result" class="list-group result-wrapper">
        </ul>
      </div>
    </div>
  </div>
</div>

  
<script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>


<script src="https://cdn.jsdelivr.net/npm/bootstrap@5/dist/js/bootstrap.min.js"></script>


<script src="/js/prism.js"></script>



  
<script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css">

  
<script src="/js/nprogress.js"></script>



 
  
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>

  
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css">

 


<script src="/js/event.js"></script>


<script src="/js/search.js"></script>


<script src="/js/plugin.js"></script>



</body>

</html>